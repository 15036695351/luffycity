1. 为什么要做前后端分离？
		- 前后端交给不同的人来编写，职责划分明确。
			- API        (IOS,安卓,PC,微信小程序...)
			- vue.js等框架编写前端时，会比之前写jQuery更简单快捷。

		- 对于后端人员，主要为前端提供：API(接口)

2.	restful的作用：帮助我们更好更快的开发符合restfulAPI的代码	

3. 谈谈你对restful规范的理解？
	1. 可以使用htts代替http 

	2. 在URL中体现自己写的是API
		https://www.luffycity.com/api/
		https://api.luffycity.com/		# 这种情况可能会跨域的问题
	3. 在URL中体现版本 ：v1/v2
	4. 名词（面向资源编程）
	5. 行为，各种求请求方式
		method:
			get,获取
			post,新建
			put,更新
			patch,局部更新
			delete,删除
		
	6. 筛选/过滤条件 	
	7. 状态码及信息
		状态码：RFC2616定义的状态码，由3位数字和原因短信组成。数字中的第一位指定了响状态码的职责是当客户端向服务器端发送请求时，描述返回请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了什么错误。
		1XX		信息性状态码，
		2XX		成功状态码
		3XX		重定向状态码
			301 Movied Permanently永久性重定向。
			302 Found临时性重定向。
		4XX		客户端错误状态码
				403 Forbidden
				404 Not Found
		5XX		服务器错误状态码
		
	8. 错误信息
	9. 返回结果：			
	10. hyper link 
		
4. django rest framework框架的作用？
	帮助开发者可以快速开发出遵循restful规范的API 
	
5. django rest framework框架都有哪些组件（10）？
	版本【1】
	权限
	认证
	节流
	分页【2】
	解析器【3】	****
	序列化		*****
	视图		****
	路由 
	渲染器【4】
	
	
6.中间件的执行顺序：
	process_request：
		1. 是在视图执行前执行的
		2. 它的顺序是从上往下
		3. 返回值是None,继续往后执行
		4. 返回值是HttpResponse的对象，执行对应中间件的process_response方法
		，接着往上，返回给浏览器

		
	process_response:
		1. 是在视图执行后执行的
		2. 它的顺序是从下往上
		3. 返回必须是HttpResponse的对象，继续往上执行
		
	process_view：
		1. 是在视图执行前执行的，process_request之后
		2. 它的顺序是从上往下
		3. 返回值是None,继续往后执行
		4. 返回值是HttpResponse的对象，执行最后一个中间件的process_response方法
		，接着往上，返回给浏览器，视图不走了
		
	process_exception：
		1. 报错了才执行
		2. 在视图函数之后，process_response之前
		3. 它的顺序是从下往上
		4. 返回值是HttpResponse的对象，执行最后一个中间件的process_response方法
		，接着往上，返回给浏览器
	

	process_template_response：
		1. 视图返回的对象有render方法 才执行
		2. 在视图函数之后，process_response之前
		3. 它的顺序是从下往上
		4. 返回值是HttpResponse的对象。
		5. 执行完所有的中间件的process_template_response之后，
		才执行对象.render()得到一个新的HttpResponse的对象，执行往交给process_response继续

7.vue实例周期的生命函数有：
	beforeCreate函数：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。

	created函数：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。

	beforeMount函数：在挂载开始之前被调用：相关的 render 函数首次被调用。该钩子在服务器端渲染期间不被调用。

	mounted函数：在挂载开始之后被调用

	beforeUpdate函数：数据更新时调用，该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。

	updated函数：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。

	beforeDestroy函数：实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。

	destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。
	
	
8.Python2和Python3的区别
	源码：
		3：源码规范，崇尚优美，清晰，简单
		2：源码混乱，重复代码较多，冗余
		
	print输出：
		python3  print（"内容"）

		python2 ptint()   或者print '内容'

	编码：
		python3 ：utf-8

		python2： 默认编码：ascii     
			解决办法：在首行加上：   #    -*- ending：utf-8-*-

	用户交互：
		input
		python2:  raw-input（）
		python3:input ()  

	Tab键：
		python2x :默认2个字节表示一个字符

		python3x：默认是4个字节表示一个字符 

	nonlocal：
		python2x：没有nonlocal

		python3x：有


	object：
		python2 中的经典类 遍历方法是以深度优先    新式类是以广度优先 

		python3 中不存在经典类  所有的类都是新式类  所以Python3中都是广度优先
9.Python3 的优点：

	1. 简单 Python的语法非常优雅，甚至没有像其他语言的大括号，分号等特殊符号，代表了一种极简主义的设计思想

	2. 易学 Python入手非常快，学习曲线非常低，可以直接通过命令行交互环境来学习Python编程。

	3. 免费/开源 Python的所有内容都是免费开源的，这意味着你不需要花一分钱就可以免费使用Python，并且你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。

	4. 自动内存管理 如果你了解C语言、C++语言你就会知道内存管理给你带来很大麻烦，程序非常容易出现内存方面的漏洞。但是在Python中内存管理是自动完成的，你可以专注于程序本身。

	5. 可以移植 由于Python是开源的，它已经被移植到了大多数平台下面，例如：Windows、MacOS、Linux、Andorid、iOS等等。

	6. 解释性 大多数计算机编程语言都是编译型的，在运行之前需要将源码编译为操作系统可以执行的二进制格式(0110格式的)，这样大型项目编译过程非常消耗时间，而Python语言写的程序不需要编译成二进制代码。你可以直接从源代码运行程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。

	7. 面向对象 Python既支持面向过程，又支持面向对象，这样编程就更加灵活。

	8. 可扩展 Python除了使用Python本身编写外，还可以混合使用像C语言、Java语言等编写。

	9. 丰富的第三方库 Python具有本身有丰富而且强大的库，而且由于Python的开源特性，第三方库也非常多，例如：在web开发、爬虫、科学计算等等

	
10.变量的命名规则
	变量名的长度不受限制，但其中的字符必须是字母、数字、或者下划线（_），而不能使用空格、连字符、标点符号、引号或其他字符。
	变量名的第一个字符不能是数字，而必须是字母或下划线。
	Python区分大小写。
	不能将Python关键字用作变量名。
	
11.垃圾回收机制和缓存池
	(1)垃圾回收机制

		1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。

		2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。

	(2)缓存池机制
		Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。

		1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。

		2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。

		3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。